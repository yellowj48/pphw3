# pphw3
Parellel Processing hw 3 assignment (scroll to bottom for the commands to compile and run programs in linux)

Problem 1 explanaiton:

In my code I aimed to solve the Minotaur's challenge of efficiently managing a massive number of birthday presents and corresponding thank you cards through concurrent programming. To achieve this, I designed a thread-safe linked list to store the presents in an ordered manner, employing mutexes to ensure that operations on shared resources, such as adding presents to the list and writing cards, are synchronized across threads. I utilized atomic operations to track the progress of presents added and cards written, eliminating the need for locking mechanisms for these counters and enhancing performance. I also integrated a utility function for generating random tasks, mimicking the dynamic nature of the workload distribution among the Minotaur's servants. My approach focused on balancing the workload across four threads, simulating the servants' efforts to tackle the tasks concurrently, thereby significantly optimizing the process and reducing the execution time. This concurrent design not only addressed the initial problem of managing an unordered collection of presents but also ensured that each present was acknowledged with a "Thank You" card, reflecting a thoughtful and efficient solution to the task at hand.

Problem 2 Explanation:

In developing the atmospheric temperature module for the next-generation Mars Rover, I use eight separate threads to simulate the operation of temperature sensors. Each thread generates temperature readings at one-minute intervals, reflecting a realistic range of -100°F to 70°F, based on a sinusoidal daily mean temperature fluctuation algorithm. The readings from each sensor are stored in a shared vector, sensorReadings, with the size allocated to accommodate an hour's worth of data from all sensors, ensuring that data collection does not impede the sensors' ability to record future readings. A combination of a mutex lock and a sensorsReady boolean vector ensures thread-safe operations, particularly when accessing and modifying shared data structures. This setup allows each sensor thread to operate independently while maintaining a synchronized state across all threads, crucial for the accuracy and timeliness of the hourly temperature report. The report itself is generated by sorting the shared vector to identify the top 5 highest and lowest temperatures, a task performed by an additional thread dedicated to report generation after confirming all sensor data for the hour has been collected. My technical approach leverages the principles of concurrency and synchronization to achieve a finely tuned balance between continuous data acquisition and comprehensive data analysis.

To compile and run problem 1:

g++ -std=c++14 present.cpp -o present -pthread

run:

./present

To compile and run problem 2:

g++ -std=c++14 temp.cpp -o temp -pthread

run:

./temp
